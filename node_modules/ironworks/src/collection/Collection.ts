
import _ = require('lodash');
import async = require('async');

import Options = require('../opts/Options');
import IWhoQuery = require('../../interfaces/whoIAm/IWhoQuery');

import IWho = require('../../interfaces/whoIAm/IWho');
import IEmit = require('../../interfaces/eventing/IEmit');

import Eventer = require('../eventing/Eventer');

import ICollection = require('../../interfaces/collection/ICollection');
import ICollectionOpts = require('../../interfaces/opts/ICollectionOpts');

class Collection<whoType extends IWho> extends Eventer implements ICollection<whoType> {
    private collection: whoType[];

    constructor(id: string, opts?: ICollectionOpts) {
        super({
            id: id,
            name: 'collection'
        });

        var defOpts: ICollectionOpts = {};
        this.opts = this.opts.beAdoptedBy<ICollectionOpts>(defOpts, 'eventer');
        this.opts.merge(opts);

        this.collection = [];
    }

    public add(item: whoType) {
        this.collection.push(item);
    }

    public addMany(items: whoType[]) {
        this.collection = this.collection.concat(items);
    }

    public remove(query: IWhoQuery, callback?: (e: Error, removed: whoType[]) => void) {
        var removed: whoType[] = [];
        var instance: Collection<whoType> = this;
        var collection: whoType[] = [];
        async.reduce<whoType, whoType[]>(this.collection, collection, (collection, item, callback) => {
            item.who((e, whoIAm) => {
                var match = false;
                var idMatch =
                    _.contains(query.ids, whoIAm.id)
                    || _.isUndefined(query.ids)
                    || query.ids.length === 0;
                var nameMatch =
                    _.contains(query.names, whoIAm.name)
                    || _.isUndefined(query.names)
                    || query.names.length === 0;
                if (!_.isUndefined(query.op) && query.op === 'or') {
                    match = idMatch || nameMatch;
                }
                else {
                    match = idMatch && nameMatch;
                }
                if (match) {
                    removed.push(item);
                }
                callback(null, collection);
            });
        }, (e, collection) => {
            instance.collection = collection;
            if (!_.isUndefined(callback)) {
                callback(e, removed);
            }
        });
    }

    public get(query: IWhoQuery, callback: (e: Error, result: whoType[]) => void) {
        var results: whoType[] = [];
        async.reduce<whoType, whoType[]>(this.collection, results, (results, item, callback) => {
            item.who((e, whoIAm) => {
                var match = false;
                var idMatch =
                    _.contains(query.ids, whoIAm.id)
                    || _.isUndefined(query.ids)
                    || query.ids.length === 0;
                var nameMatch =
                    _.contains(query.names, whoIAm.name)
                    || _.isUndefined(query.names)
                    || query.names.length === 0;
                if (!_.isUndefined(query.op) && query.op === 'or') {
                    match = idMatch || nameMatch;
                }
                else {
                    match = idMatch && nameMatch;
                }
                if (match) {
                    results.push(item);
                }
                callback(null, results);
            });
        }, (e, results) => {
            if (!_.isUndefined(callback)) {
                callback(e, results);
            }
        });
    }

    public list(): whoType[] {
        return this.collection;
    }

    public clear() {
        this.collection = [];
    }

    public each(iterator: (item: whoType, itemDone: (e: Error) => void) => void, allDone?: (e: Error) => void) {
        async.each(this.collection, iterator, allDone);
    }

    public dispose(callback?: () => void) {
        this.clear();
        super.dispose(callback);
    }
}

export = Collection;
