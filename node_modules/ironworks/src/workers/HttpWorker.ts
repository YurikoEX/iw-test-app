
import path = require('path');

import _ = require('lodash');
import hapi = require('hapi');

import IComm = require('../../interfaces/eventing/IComm');
import idHelper = require('..//helpers/idHelper');
import IAm = require('../../interfaces/whoIAm/IAm');
import Options = require('../opts/Options');
import ICommEmit = require('../../interfaces/eventing/ICommEmit');
import CommEmit = require('..//eventing/CommEmit');
import IDependency = require('../../interfaces/workers/IDependency');
import ICollection = require('../../interfaces/collection/ICollection');
import IWorkerChild = require('../../interfaces/workers/IWorkerChild');

import Worker = require('../../src/workers/Worker');

import IHttpWorker = require('../../interfaces/workers/IHttpWorker');
import IHttpWorkerOpts = require('../../interfaces/opts/IHttpWorkerOpts');

class HttpWorker extends Worker implements IHttpWorker {
    public httpServer: hapi.Server;

    constructor(comm: IComm, service: IAm, opts?: IHttpWorkerOpts) {
        super([], comm, service, {
            id: idHelper.newId(),
            name: 'iw-http'
        });

        var defOpts: IHttpWorkerOpts = {
            port: process.env.VCAP_APP_PORT,
            rootSitePagePath: 'index.html'
        };
        this.opts = this.opts.beAdoptedBy<IHttpWorkerOpts>(defOpts, 'worker');
        this.opts.merge(opts);
    }

    public init(callback?: (e: Error) => void) {
        var instance = this;

        this.httpServer = new hapi.Server(this.opts.get<hapi.IServerOptions>('hapi'));
        this.httpServer.connection({
            port: this.opts.get<number>('port')
        });

        var serveApi = this.opts.has('apiUri');
        if (serveApi) {
            var api = this.opts.get<string>('apiUri');
            if (api[0] !== '/') {
                api = '/' + api;
            }
            if (api[api.length - 1] === '/') {
                api = api.substring(0, api.length - 1);
            }
            this.httpServer.route({
                method: 'POST',
                path: api + '/{prefix}/{service}/{method}/{worker}/{event}',
                config: {
                    payload: {
                        allow: 'application/json',
                        parse: true
                    },
                },
                handler: (req: hapi.Request, reply: hapi.IReply) => {
                    var event: ICommEmit = new CommEmit({
                        id: idHelper.newId(),
                        emitter: {
                            id: _.isUndefined(req.query.myId) ? instance.me.id : req.query.myId,
                            name: _.isUndefined(req.query.myName) ? instance.me.name : req.query.myName
                        },
                        prefix: req.paramsArray[0],
                        service: req.paramsArray[1],
                        method: req.paramsArray[2],
                        worker: req.paramsArray[3],
                        name: req.paramsArray[4]
                    });
                    switch (event.method) {
                        case 'tell':
                            if (req.method !== 'post') {
                                return;
                            }
                            instance.tell(event);
                            reply(200);
                            break;
                        case 'inform':
                            if (req.method !== 'post') {
                                return;
                            }
                            instance.inform(event, req.payload);
                            reply(200);
                            break;
                        case 'confirm':
                            instance.confirm(event, (e) => {
                                reply(e === null ? 200 : e);
                            });
                            break;
                        case 'ask':
                            instance.ask(event, (e, answer) => {
                                reply(e, answer);
                            });
                            break;
                        case 'request':
                            instance.request(event, req.payload, (e, response) => {
                                reply(e, response);
                            });
                            break;
                    }
                }
            });
            this.httpServer.route({
                method: 'GET',
                path: api + '/{prefix}/{service}/{method}/{worker}/{event}',
                handler: (req: hapi.Request, reply: hapi.IReply) => {
                    var event: ICommEmit = new CommEmit({
                        id: idHelper.newId(),
                        emitter: {
                            id: _.isUndefined(req.query.myId) ? instance.me.id : req.query.myId,
                            name: _.isUndefined(req.query.myName) ? instance.me.name : req.query.myName
                        },
                        prefix: req.paramsArray[0],
                        service: req.paramsArray[1],
                        method: req.paramsArray[2],
                        worker: req.paramsArray[3],
                        name: req.paramsArray[4]
                    });
                    switch (event.method) {
                        case 'tell':
                            if (req.method !== 'post') {
                                return;
                            }
                            instance.tell(event);
                            reply(200);
                            break;
                        case 'inform':
                            if (req.method !== 'post') {
                                return;
                            }
                            instance.inform(event, req.payload);
                            reply(200);
                            break;
                        case 'confirm':
                            instance.confirm(event, (e) => {
                                reply(e === null ? 200 : e);
                            });
                            break;
                        case 'ask':
                            instance.ask(event, (e, answer) => {
                                reply(e, answer);
                            });
                            break;
                        case 'request':
                            instance.request(event, req.payload, (e, response) => {
                                reply(e, response);
                            });
                            break;
                    }
                }
            });
        }
        var servePublicRoot = this.opts.has('hapi.connections.routes.files.relativeTo');
        if (servePublicRoot) {
            this.httpServer.route({
                method: 'GET',
                path: '/{p*}',
                handler: (req: hapi.Request, reply: hapi.IReply) => {
                    if (req.path === '/') {
                        req.path = instance.opts.get<string>('rootSitePagePath');
                    }
                    var root = instance.opts.get<string>('hapi.connections.routes.files.relativeTo');
                    var filePath = path.join(root, req.path);
                    reply.file(filePath);
                }
            });
        }
        if (!_.isUndefined(callback)) {
            callback(null);
        }
    }

    public start(dependencies: ICollection<IDependency<IWorkerChild>>, callback?: (e: Error) => void) {
        this.httpServer.start((e: Error) => {
            if (_.isUndefined(e)) {
                e = null;
            }
            if (e === null) {
                this.tell('ready');
            }
            else {
                this.inform<Error>('error', e);
            }
            if (!_.isUndefined(callback)) {
                process.nextTick(() => {
                    callback(e);
                });
            }
        });
    }

    public dispose(callback?: () => void) {
        if (!_.isUndefined(this.httpServer)) {
            this.httpServer.stop(void 0, () => {
                if (!_.isUndefined(callback)) {
                    callback();
                }
            });
        }
        else {
            if (!_.isUndefined(callback)) {
                process.nextTick(() => {
                    callback();
                });
            }
        }
    }
}

export = HttpWorker;
